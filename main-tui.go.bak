package main

import (
	"context"
	"fmt"
	"log"
	"sync"

	"github.com/gdamore/tcell/v2"
	"github.com/rivo/tview"
)

type App struct {
	app            *tview.Application
	docker         *DockerClient
	logView        *tview.TextView
	containerList  *tview.List
	searchInput    *tview.InputField
	statusBar      *tview.TextView
	
	logs           []LogMessage
	logsMutex      sync.RWMutex
	
	containers         []Container
	selectedContainers map[string]bool
	searchQuery       string
	traceFilter       string
	traceFilterType   string
	
	logChan        chan LogMessage
	ctx            context.Context
	cancel         context.CancelFunc
}

func NewApp() (*App, error) {
	docker, err := NewDockerClient()
	if err != nil {
		return nil, err
	}

	ctx, cancel := context.WithCancel(context.Background())

	app := &App{
		app:                tview.NewApplication(),
		docker:             docker,
		logs:               make([]LogMessage, 0),
		selectedContainers: make(map[string]bool),
		logChan:            make(chan LogMessage, 1000),
		ctx:                ctx,
		cancel:             cancel,
	}

	app.setupUI()
	return app, nil
}

func (a *App) setupUI() {
	a.logView = tview.NewTextView().
		SetDynamicColors(true).
		SetScrollable(true).
		SetChangedFunc(func() {
			a.app.Draw()
		})
	a.logView.SetBorder(true).SetTitle(" Logs ")

	a.containerList = tview.NewList().
		ShowSecondaryText(false)
	a.containerList.SetBorder(true).SetTitle(" Containers (Space to toggle) ")
	
	a.searchInput = tview.NewInputField().
		SetLabel("Search: ").
		SetFieldWidth(50).
		SetChangedFunc(func(text string) {
			a.searchQuery = text
			a.updateLogView()
		})
	a.searchInput.SetBorder(true)

	a.statusBar = tview.NewTextView().
		SetDynamicColors(true).
		SetText("[yellow]Loading containers...")
	
	searchBox := tview.NewFlex().
		SetDirection(tview.FlexRow).
		AddItem(a.searchInput, 3, 0, false).
		AddItem(a.statusBar, 1, 0, false)

	leftPanel := tview.NewFlex().
		SetDirection(tview.FlexRow).
		AddItem(a.containerList, 0, 1, true).
		AddItem(searchBox, 4, 0, false)

	mainLayout := tview.NewFlex().
		AddItem(leftPanel, 40, 0, true).
		AddItem(a.logView, 0, 1, false)

	a.containerList.SetInputCapture(func(event *tcell.EventKey) *tcell.EventKey {
		if event.Key() == tcell.KeyRune && event.Rune() == ' ' {
			index := a.containerList.GetCurrentItem()
			if index >= 0 && index < len(a.containers) {
				containerID := a.containers[index].ID
				
				if a.selectedContainers[containerID] {
					delete(a.selectedContainers, containerID)
				} else {
					a.selectedContainers[containerID] = true
				}
				a.updateContainerList()
				a.updateLogView()
			}
			return nil
		}
		return event
	})

	a.app.SetInputCapture(func(event *tcell.EventKey) *tcell.EventKey {
		switch event.Key() {
		case tcell.KeyCtrlC:
			a.app.Stop()
			return nil
		case tcell.KeyTab:
			if a.app.GetFocus() == a.containerList {
				a.app.SetFocus(a.searchInput)
			} else if a.app.GetFocus() == a.searchInput {
				a.app.SetFocus(a.logView)
			} else {
				a.app.SetFocus(a.containerList)
			}
			return nil
		case tcell.KeyCtrlL:
			a.logsMutex.Lock()
			a.logs = make([]LogMessage, 0)
			a.logsMutex.Unlock()
			a.updateLogView()
			return nil
		case tcell.KeyCtrlT:
			a.traceFilter = ""
			a.traceFilterType = ""
			a.updateLogView()
			a.updateStatus("Trace filter cleared")
			return nil
		case tcell.KeyRune:
			if event.Rune() == 'r' && a.app.GetFocus() == a.logView {
				a.filterByFieldFromCurrentLog("request_id")
				return nil
			} else if event.Rune() == 's' && a.app.GetFocus() == a.logView {
				a.filterByFieldFromCurrentLog("span_id")
				return nil
			} else if event.Rune() == 't' && a.app.GetFocus() == a.logView {
				a.filterByFieldFromCurrentLog("trace_id")
				return nil
			}
		}
		return event
	})

	a.app.SetRoot(mainLayout, true)
}

func (a *App) toggleContainer(containerID string) {
	if a.selectedContainers[containerID] {
		delete(a.selectedContainers, containerID)
	} else {
		a.selectedContainers[containerID] = true
	}
	a.updateLogView()
}

func (a *App) loadContainers() error {
	containers, err := a.docker.ListRunningContainers(a.ctx)
	if err != nil {
		return err
	}

	a.containers = containers
	a.containerList.Clear()
	
	for _, c := range containers {
		a.selectedContainers[c.ID] = true
		a.containerList.AddItem(c.ID, "", 0, nil)
		
		if err := a.docker.StreamLogs(a.ctx, c.ID, a.logChan); err != nil {
			log.Printf("Failed to stream logs for container %s: %v", c.ID, err)
		}
	}

	a.updateContainerList()
	a.updateStatus(fmt.Sprintf("Monitoring %d containers", len(containers)))
	return nil
}

func (a *App) updateContainerList() {
	for i := 0; i < a.containerList.GetItemCount(); i++ {
		if i >= len(a.containers) {
			continue
		}
		
		c := a.containers[i]
		prefix := "[ ]"
		if a.selectedContainers[c.ID] {
			prefix = "[X]"
		}
		
		displayText := fmt.Sprintf("%s %s %s", prefix, c.ID, c.Name)
		a.containerList.SetItemText(i, displayText, "")
	}
}

func (a *App) updateLogView() {
	a.logsMutex.RLock()
	defer a.logsMutex.RUnlock()

	a.logView.Clear()
	
	startIdx := 0
	if len(a.logs) > 1000 {
		startIdx = len(a.logs) - 1000
	}
	
	for i := startIdx; i < len(a.logs); i++ {
		msg := a.logs[i]
		
		if !a.selectedContainers[msg.ContainerID] {
			continue
		}
		
		if a.searchQuery != "" && !msg.Entry.MatchesSearch(a.searchQuery) {
			continue
		}
		
		if a.traceFilter != "" {
			if val, ok := msg.Entry.Fields[a.traceFilterType]; !ok || val != a.traceFilter {
				continue
			}
		}
		
		fmt.Fprintf(a.logView, "[gray]%s[white] %s\n", 
			msg.ContainerID, 
			msg.Entry.FormattedString())
	}
	
	a.logView.ScrollToEnd()
}

func (a *App) updateStatus(msg string) {
	filterInfo := ""
	if a.traceFilter != "" {
		filterInfo = fmt.Sprintf(" | [yellow]Filter: %s=%s[white]", a.traceFilterType, a.traceFilter)
	}
	a.statusBar.SetText(fmt.Sprintf("[green]%s[white] | Logs: %d%s | r/s/t: filter | Ctrl+T: clear filter | Ctrl+L: clear | Ctrl+C: quit", 
		msg, len(a.logs), filterInfo))
}

func (a *App) filterByFieldFromCurrentLog(fieldName string) {
	a.logsMutex.RLock()
	defer a.logsMutex.RUnlock()
	
	if len(a.logs) == 0 {
		return
	}
	
	for i := len(a.logs) - 1; i >= 0; i-- {
		msg := a.logs[i]
		if !a.selectedContainers[msg.ContainerID] {
			continue
		}
		if a.searchQuery != "" && !msg.Entry.MatchesSearch(a.searchQuery) {
			continue
		}
		
		if val, ok := msg.Entry.Fields[fieldName]; ok {
			a.traceFilter = val
			a.traceFilterType = fieldName
			a.updateLogView()
			a.updateStatus(fmt.Sprintf("Filtering by %s", fieldName))
			return
		}
	}
	
	a.updateStatus(fmt.Sprintf("No %s found in recent logs", fieldName))
}

func (a *App) processLogs() {
	for {
		select {
		case <-a.ctx.Done():
			return
		case msg := <-a.logChan:
			a.logsMutex.Lock()
			a.logs = append(a.logs, msg)
			if len(a.logs) > 10000 {
				a.logs = a.logs[1000:]
			}
			a.logsMutex.Unlock()
			
			if a.selectedContainers[msg.ContainerID] {
				shouldShow := true
				if a.searchQuery != "" && !msg.Entry.MatchesSearch(a.searchQuery) {
					shouldShow = false
				}
				if a.traceFilter != "" {
					if val, ok := msg.Entry.Fields[a.traceFilterType]; !ok || val != a.traceFilter {
						shouldShow = false
					}
				}
				
				if shouldShow {
					a.app.QueueUpdateDraw(func() {
						fmt.Fprintf(a.logView, "[gray]%s[white] %s\n", 
							msg.ContainerID, 
							msg.Entry.FormattedString())
						a.logView.ScrollToEnd()
						a.updateStatus(fmt.Sprintf("Streaming"))
					})
				}
			}
		}
	}
}

func (a *App) Run() error {
	if err := a.loadContainers(); err != nil {
		return fmt.Errorf("failed to load containers: %w", err)
	}

	go a.processLogs()

	return a.app.Run()
}

func (a *App) Close() {
	a.cancel()
	if a.docker != nil {
		a.docker.Close()
	}
}

func main() {
	app, err := NewApp()
	if err != nil {
		log.Fatalf("Failed to create app: %v", err)
	}
	defer app.Close()

	if err := app.Run(); err != nil {
		log.Fatalf("Failed to run app: %v", err)
	}
}
